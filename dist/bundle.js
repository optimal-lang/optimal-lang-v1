/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/oml2ast.js"
/*!************************!*\
  !*** ./src/oml2ast.js ***!
  \************************/
(__unused_webpack_module, exports) {

eval("{function tokenize(str) {\n  let re = /[\\s,]*([()\\[\\]{}'`]|\"(?:\\\\.|[^\\\\\"])*\"|@(?:@@|[^@])*@|;.*|#.*|[^\\s,()\\[\\]{}'\"`;@]*)/g;\n  let result = [];\n  let token;\n  while ((token = re.exec(str)[1]) !== \"\") {\n    if (token[0] === \";\") continue;\n    if (token[0] === \"#\") continue;\n    if (isFinite(token)) token = parseFloat(token, 10);\n    result.push(token);\n  }\n  return result;\n}\n\nfunction read_token(code, exp) {\n  if (code.length === 0) return undefined;\n  let token = code.shift();\n  exp.push(token);\n  return token;\n}\n\nfunction read_list(code, exp, ch) {\n  let result = [];\n  let ast;\n  while ((ast = read_sexp(code, exp, false)) !== undefined) {\n    if (ast === \"]\") {\n      if (ch !== \"[\") code.unshift(\"]\");\n      break;\n    } else if (ast === \")\") {\n      break;\n    }\n    result.push(ast);\n  }\n  return result;\n}\n\nfunction read_dict(code, exp) {\n  let result = [[\"#\", \"dict\"]];\n  let ast1;\n  let ast2;\n  while ((ast1 = read_sexp(code, exp)) !== undefined) {\n    if (ast1 === \"]\") continue;\n    if (ast1 === \"}\") break;\n    ast2 = read_sexp(code, exp);\n    result.push(ast1);\n    result.push(ast2);\n  }\n  return result;\n}\n\nfunction read_sexp(code, exp) {\n  let token = read_token(code, exp);\n  if (token === undefined) return undefined;\n  if ((typeof token) === \"number\") return token;\n  switch (token) {\n  case \"false\":\n    return false;\n  case \"true\":\n    return true;\n  case \"null\":\n    return null;\n  case \"undefined\":\n    return [\"@\", \"undefined\"];\n  }\n  let ch = token[0];\n  switch (ch) {\n  case \"(\":\n  case \"[\":\n    let lst = read_list(code, exp, ch);\n    return lst;\n  case \")\":\n  case \"]\":\n    return ch;\n  case \"{\":\n    return read_dict(code, exp);\n  case \"}\":\n    return ch;\n  case '\"':\n    token = JSON.parse(token);\n    return token;\n  case \"@\":\n    token = token.replace(/(^@|@$)/g, \"\");\n    token = token.replace(/(@@)/g, \"@\");\n    return [\"@\", token];\n  default: {\n    if (token[0] === \":\") return token;\n    if (token[0] === \"&\") return token;\n    let ids = token[0] === \".\" ? [token] : token.split(\".\");\n    return [\"#\", ...ids];\n  }\n  }\n}\n\nfunction join_sexp(exp) {\n  if (exp.length === 0) return \"\";\n  let last = exp.shift();\n  let result = \"\" + last;\n  while (exp.length > 0) {\n    let token = exp.shift();\n    if (\n      token !== \")\" &&\n        token !== \"]\" &&\n        (last !== \"(\") & (last !== \"[\") &&\n        last !== \"'\"\n    )\n      result += \" \";\n    if (token === \"[\") token = \"(\";\n    if (token === \"]\") token = \")\";\n    result += token;\n    last = token;\n  }\n  return result;\n}\n\nfunction oml2ast(text) {\n  let code = tokenize(text);\n  let result = [];\n  while (true) {\n    let exp = [];\n    let ast = read_sexp(code, exp);\n    if (ast === undefined) break;\n    if (ast === \")\") continue;\n    if (ast === \"]\") continue;\n    result.push([join_sexp(exp), ast]);\n  }\n  return result;\n}\nexports.oml2ast = oml2ast;\n\nfunction ast2oml(ast) {\n  if (ast === null) return \"null\";\n  if (ast === undefined) return \"undefined\";\n  if ((typeof ast) === \"number\") return JSON.stringify(ast);\n  if ((typeof ast) === \"string\") return JSON.stringify(ast);\n  if ((typeof ast) === \"boolean\") return JSON.stringify(ast);\n  if (ast instanceof Array) {\n    let result = \"( \";\n    for (let i = 0; i < ast.length; i++) {\n      if (i > 0) result += \" \";\n      result += ast2oml(ast[i]);\n    }\n    let keys = Object.keys(ast);\n    let re = /^[0-9]+/;\n    keys = keys.filter(key => !re.test(key));\n    keys.sort();\n    if (keys.length > 0) {\n      if (ast.length > 0) result += \" \";\n      result += \"?\";\n      for (let i=0; i<keys.length; i++) {\n        let key = keys[i];\n        result += \" (\";\n        result += JSON.stringify(key);\n        result += \" \";\n        result += ast2oml(ast[key]);\n        result += \")\";\n      }\n    }\n    result += \" )\";\n    return result;\n  } else {\n    let result = \"{ \";\n    let keys = Object.keys(ast);\n    keys.sort();\n    for (let i = 0; i < keys.length; i++) {\n      if (i > 0) result += \" \";\n      result += JSON.stringify(keys[i]);\n      result += \" \";\n      result += ast2oml(ast[keys[i]]);\n    }\n    result += \" }\";\n    return result;\n  }\n}\nexports.ast2oml = ast2oml;\n\nfunction astequal(a, b) {\n  // primitive\n  if (a === b) {\n    return true;\n  }\n  if (a instanceof Function || b instanceof Function) {\n    // Function\n    //console.log(\"function not supported!\")\n    return false;\n  } else if (typeof (a) === 'object' && typeof (b) === 'object') {\n    // Object\n    const ak = Object.keys(a);\n    const bk = Object.keys(b);\n    if (ak.length !== bk.length) {\n      return false;\n    }\n    for (let i = 0; i < ak.length; ++i) {\n      const key = ak[i];\n      const ret = astequal(a[key], b[key]);\n      if (ret === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nexports.astequal = astequal;\n\n\n//# sourceURL=webpack:///./src/oml2ast.js?\n}");

/***/ },

/***/ "./src/omlcommon.js"
/*!**************************!*\
  !*** ./src/omlcommon.js ***!
  \**************************/
(__unused_webpack_module, exports) {

eval("{class OMLCommon {\n  is_array(x) {\n    return (x instanceof Array);\n  }\n\n  is_bool(x) {\n    return (typeof x) === \"boolean\";\n  }\n\n  is_number(x) {\n    return (typeof x) === \"number\";\n  }\n\n  is_string(x) {\n    return (typeof x) === \"string\";\n  }\n\n  is_quoted(x) {\n    if (!this.is_array(x)) return false;\n    if (x.length === 0) return false;\n    return x[0] === \"`\";\n  }\n\n  is_id(ast, name = undefined) {\n    let ok = ast instanceof Array && ast[0] === \"#\";\n    if (!ok) return false;\n    return name ? ast[1]===name : true;\n  }\n\n  is_variable(ast) {\n    if (!(ast instanceof Array)) false;\n    if (ast.length === 0) return false;\n    return ast[0] === \"#\";\n  }\n\n  is_script(ast) {\n    if (!(ast instanceof Array)) false;\n    if (ast.length === 0) return false;\n    return ast[0] === \"@\";\n  }\n\n  is_callable(ast) {\n    if (!(ast instanceof Array)) false;\n    if (ast.length === 0) return false;\n    if (ast[0] === \"#\") return false;\n    if (ast[0] === \"@\") return false;\n    return this.is_id(ast[0]) || this.is_script(ast[0]);\n  }\n\n  is_fn(ast) {\n    if (!(ast instanceof Array)) false;\n    if (ast.length === 0) return false;\n    return this.is_id(ast[0]) && this.to_id(ast[0])===\"fn\";\n  }\n\n  to_id(ast) {\n    if (this.is_id(ast)) {\n      let ids = ast.slice(1);\n      return ids.join(\".\");\n    } else if (this.is_script(ast)) {\n      return \"@\";\n    }\n    return ast;\n  }\n\n  id(x) {\n    return [\"#\", x];\n  }\n\n  to_def(ast) {\n    if (!this.is_array(ast)) return null;\n    if (ast.length === 0) return null;\n    switch (this.to_id(ast[0])) {\n    case \"def\": {\n      if (ast.length < 2) throw new Error(\"sysntax error\");\n      let ast1 = ast[1];\n      let ast2 = ast.length === 2 ? null : ast[2];\n      return [this.id(\"def\"), ast1, ast2];\n    }\n    case \"defvar\": {\n      if (ast.length < 2) throw new Error(\"sysntax error\");\n      let ast1 = ast[1];\n      let ast2 = ast.length === 2 ? null : ast[2];\n      return [this.id(\"def\"), ast1, ast2];\n    }\n    case \"defun\": {\n      let new_ast = ast.slice(3);\n      new_ast.unshift(ast[2]);\n      new_ast.unshift(this.id(\"fn\"));\n      return [this.id(\"def\"), ast[1], new_ast];\n    }\n    case \"define\": {\n      let ast1 = this.to_id(ast[1]);\n      if (ast1 instanceof Array) {\n        if (ast.length < 2) throw new Error(\"sysntax error\");\n        let new_ast = ast.slice(2);\n        return this.to_def([this.id(\"defun\"), ast[1][0], ast[1].slice(1), ...new_ast]);\n      }\n      else {\n        if (ast.length < 2) throw new Error(\"sysntax error\");\n        let ast1 = ast[1];\n        let ast2 = ast.length === 2 ? null : ast[2];\n        return this.to_def([this.id(\"defvar\"), ast1, ast2]);\n      }\n    }\n    default:\n      return null;\n    }\n  }\n\n}\nexports.OMLCommon = OMLCommon;\n\n\n//# sourceURL=webpack:///./src/omlcommon.js?\n}");

/***/ },

/***/ "./src/omljs.js"
/*!**********************!*\
  !*** ./src/omljs.js ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _oml2ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oml2ast.js */ \"./src/oml2ast.js\");\n/* harmony import */ var _omlcommon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./omlcommon.js */ \"./src/omlcommon.js\");\n\n\n\nlet common = new _omlcommon_js__WEBPACK_IMPORTED_MODULE_1__.OMLCommon();\n\nfunction compile_number(ast) {\n  return `number_value(${compile_ast(ast)})`;\n}\n\nfunction compile_string(ast) {\n  return `String(${compile_ast(ast)})`;\n}\n\nfunction compile_body_helper(body) {\n  if (body.length === 0) return null;\n  let result = \"(\";\n  for (let i = 0; i < body.length; i++) {\n    if (i > 0)\n      result += \",\";\n    let def = common.to_def(body[i]);\n    if (def !== null) {\n      let let_ast = [common.id(\"let\"), [[def[1], def[2]]], ...body.slice(i + 1)];\n      return result + compile_ast(let_ast) + \")\";\n    }\n    result += compile_ast(body[i]);\n  }\n  return result + \")\";\n}\n\nfunction compile_body(ast, start) {\n  let body = [];\n  for (let i = start; i < ast.length; i++) {\n    body.push(ast[i]);\n  }\n  return compile_body_helper(body);\n}\n\nfunction compile_ast(ast) {\n  if (ast === null)\n    return \"null\";\n  if (ast === undefined)\n    return \"undefined\";\n  /*\n    if (!ast) {\n    return JSON.stringify(ast);\n    }\n  */\n  if (typeof ast === \"string\") {\n    /*\n      if (ast.match(/^:.+$/) || ast.match(/^#.+$/))\n      return JSON.stringify(ast);\n      return ast;\n    */\n    return JSON.stringify(ast);\n  }\n  if (!(ast instanceof Array)) {\n    return ast.toString();\n  }\n  if (ast.length === 0)\n    return \"[]\";\n  if (common.is_variable(ast)) {\n    return common.to_id(ast);\n  }\n  if (common.is_script(ast)) {\n    return ast[1];\n  }\n  if (common.is_id(ast[0]) && common.to_id(ast[0])===\"?\") {\n    return compile_ast([common.id(\"list\"), ...ast]);\n  }\n  if (!common.is_callable(ast)) {\n    return compile_ast([common.id(\"list\"), ...ast]);\n  }\n  switch (common.to_id(ast[0])) {\n  case \"@\": {\n    let fcall = ast[0][1] + \"(\";\n    for (let i = 1; i < ast.length; i++) {\n      if (i > 1)\n        fcall += \",\";\n      fcall += compile_ast(ast[i]);\n    }\n    fcall += \")\";\n    return fcall;\n  }\n  case \"begin\":\n    return compile_body(ast, 1);\n  case \"case\": {\n    let cond_ast = [common.id(\"cond\")];\n    for (let i=2; i<ast.length; i++) {\n      let e = ast[i];\n      if (common.is_id(e[0], \"else\") || common.is_id(e[0], \"otherwise\")) {\n        cond_ast.push(e);\n      } else {\n        cond_ast.push([[common.id(\"equal\"), common.id(\"__case__\"), e[0]],...e.slice(1)]);\n      }\n    }\n    //return compile_ast([common.id(\"let*\"), [[common.id(\"__case__\"), ast[1]]], cond_ast]);\n    let new_ast = [common.id(\"let*\"), [[common.id(\"__case__\"), ast[1]]], cond_ast];\n    //print(new_ast);\n    return compile_ast(new_ast);\n  }\n  case \"_cond\": {\n    function _cond_builder(rest) {\n      if (rest.length === 0)\n        return null;\n      let condition = rest.shift();\n      condition = common.to_id(condition);\n      let action = rest.shift();\n      switch (condition) {\n      case true:\n      case \"else\":\n      case \"otherwise\":\n        return action;\n      }\n      return [common.id(\"if\"), condition, action, _cond_builder(rest)];\n    }\n    ast = _cond_builder(ast.slice(1));\n    return compile_ast(ast);\n  }\n  case \"cond\": {\n    let new_ast = [];\n    ast.slice(1).forEach((x) => {\n      new_ast.push(x[0]);\n      new_ast.push([[\"#\", \"begin\"]].concat(x.slice(1)));\n    });\n    new_ast.unshift([\"#\", \"_cond\"]);\n    return compile_ast(new_ast);\n  }\n  case \"dec!\":\n  case \"inc!\":\n    let sign = common.to_id(ast[0]) === \"dec!\" ? \"-\" : \"+\";\n    let val = ast.length < 3 ? 1 : compile_ast(ast[2]);\n    return compile_ast(ast[1]) + sign + \"=\" + val;\n  case \"def\": {\n    ast = common.to_def(ast);\n    return \"globalThis.\" + common.to_id(ast[1]) + \"=\" + compile_ast(ast[2]);\n  }\n  case \"define\": case \"defun\": case \"defvar\": {\n    ast = common.to_def(ast);\n    return compile_ast(ast);\n  }\n  case \"do\":\n  case \"do*\":\n    return compile_do(ast);\n  case \"fn\":\n  case \"lambda\": {\n    let args = \"(\";\n    for (let i = 0; i < ast[1].length; i++) {\n      if (i > 0)\n        args += \",\";\n      args += common.to_id(ast[1][i]);\n    }\n    args += \")\";\n    if (ast.length < 3)\n      return \"function\" + args + \"{}\";\n    return \"function\" + args + \"{return \" + compile_body(ast, 2) + \"}\";\n  }\n  case \"dotimes\": {\n    let ast1 = ast[1];\n    if (!common.is_array(ast1) || common.is_quoted(ast1))\n      ast1 = [common.id(\"$index\"), ast1];\n    else if (ast1.length < 2)\n      throw new Error(\"syntax error\");\n    let result_exp = ast1.length < 3 ? common.id(\"null\") : ast1[2];\n    let bind = [\n      [common.id(\"__dotimes_cnt__\"), ast1[1]],\n      [common.id(\"__dotimes_idx__\"), 0, [common.id(\"+\"), common.id(\"__dotimes_idx__\"), 1]],\n      [ast1[0], common.id(\"__dotimes_idx__\"), common.id(\"__dotimes_idx__\")],\n    ];\n    let exit = [[common.id(\">=\"), common.id(\"__dotimes_idx__\"), common.id(\"__dotimes_cnt__\")], result_exp];\n    ast = [common.id(\"do*\"), bind, exit].concat(ast.slice(2));\n    return compile_ast(ast);\n  }\n  case \"length\": {\n    if (ast.length != 2) return new Error(\"syntax error\");\n    return \"(\" + compile_ast(ast[1]) + \").length\";\n  }\n  case \"prop-get\": {\n    if (ast.length != 3) return new Error(\"syntax error\");\n    return compile_ast(ast[1]) + \"[\" + compile_ast(ast[2]) + \"]\";\n  }\n  case \"prop-set!\": {\n    if (ast.length != 4) return new Error(\"syntax error\");\n    return compile_ast(ast[1]) + \"[\" + compile_ast(ast[2]) + \"]=\" + compile_ast(ast[3]);\n  }\n  case \"dolist\": {\n    let ast1 = ast[1];\n    if (common.is_variable(ast1) || !common.is_array(ast1) || common.is_quoted(ast1))\n      ast1 = [common.id(\"$item\"), ast1];\n    else if (ast1.length < 2)\n      throw new Error(\"syntax error\");\n    let result_exp = ast1.length < 3 ? common.id(\"null\") : ast1[2];\n    let bind = [\n      [common.id(\"__dolist_list__\"), ast1[1]],\n      [common.id(\"__dolist_cnt__\"), [common.id(\"length\"), common.id(\"__dolist_list__\")]],\n      [common.id(\"__dolist_idx__\"), 0, [common.id(\"+\"), common.id(\"__dolist_idx__\"), 1]],\n      [ast1[0], [common.id(\"prop-get\"), common.id(\"__dolist_list__\"), common.id(\"__dolist_idx__\")], [common.id(\"prop-get\"), common.id(\"__dolist_list__\"), common.id(\"__dolist_idx__\")]],\n    ];\n    let exit = [[common.id(\">=\"), common.id(\"__dolist_idx__\"), common.id(\"__dolist_cnt__\")], result_exp];\n    ast = [common.id(\"do*\"), bind, exit].concat(ast.slice(2));\n    return compile_ast(ast);\n  }\n  case \"if\":\n    return (\"(\" +\n            compile_ast(ast[1]) +\n            \"?\" +\n            compile_ast(ast[2]) +\n            \":\" +\n            compile_body(ast, 3) +\n            \")\");\n  case \"let\":\n  case \"let*\": {\n    let ast1 = ast[1];\n    let new_ast1 = [];\n    for (let x of ast1) {\n      if (typeof x === \"string\") {\n        new_ast1.push(x);\n        new_ast1.push(undefined);\n      }\n      else {\n        new_ast1.push(x[0]);\n        new_ast1.push(x[1]);\n      }\n    }\n    return compile_ast([common.id(\"_\" + common.to_id(ast[0])), new_ast1].concat(ast.slice(2)));\n  }\n  case \"_let\":\n  case \"_let*\": {\n    let vars = \"(\";\n    let vals = \"(\";\n    let assigns = \"\";\n    for (let i = 1; i < ast[1].length; i += 2) {\n      if (i > 1)\n        vars += \",\";\n      vars += common.to_id(ast[1][i - 1]);\n      let val = compile_ast(ast[1][i]);\n      if (i > 1)\n        vals += \",\";\n      vals += val;\n      assigns += common.to_id(ast[1][i - 1]) + \"=\" + val + \";\";\n    }\n    vars += \")\";\n    vals += \")\";\n    if (common.to_id(ast[0]) === \"_let\")\n      return (\"((function\" +\n              vars +\n              \"{return \" +\n              compile_body(ast, 2) +\n              \"})\" +\n              vals +\n              \")\");\n    else\n      return (\"((function\" +\n              vars +\n              \"{\" +\n              assigns +\n              \"return \" +\n              compile_body(ast, 2) +\n              \"})())\");\n  }\n  case \"list\": {\n    ast = ast.slice(1);\n    let found = -1;\n    for (let i = 0; i < ast.length; i++) {\n      let e = ast[i];\n      if (common.is_id(e) && common.to_id(e) === \"?\") {\n        found = i;\n        break;\n      }\n    }\n    let list;\n    let dict;\n    if (found === -1) {\n      list = ast;\n      dict = [];\n    } else if (found === 0) {\n      list = [];\n      dict = ast.slice(1);\n    } else {\n      list = ast.slice(0, found);\n      dict = ast.slice(found + 1);\n    }\n    let body = [];\n    for (let i = 0; i < list.length; i++) {\n      body.push([common.id(\"prop-set!\"), common.id(\"__obj__\"), i, list[i]]);\n    }\n    for (let i = 0; i < dict.length; i++) {\n      let pair = dict[i];\n      if (common.is_string(pair)) pair = [pair, true];\n      body.push([common.id(\"prop-set!\"), common.id(\"__obj__\"), pair[0], pair[1]]);\n    }\n    body.push(common.id(\"__obj__\"));\n    ast = [common.id(\"let*\"), [[common.id(\"__obj__\"), [\"@\", \"[]\"]]], ...body];\n    return compile_ast(ast);\n  }\n  case \"dict\": {\n    if ((ast.length % 2) !== 1) throw new Error(\"synatx error\");\n    let body = [];\n    for (let i = 1; i < ast.length; i += 2) {\n      body.push([common.id(\"prop-set!\"), common.id(\"__dict__\"), ast[i], ast[i + 1]]);\n    }\n    body.push(common.id(\"__dict__\"));\n    ast = [common.id(\"let*\"), [[common.id(\"__dict__\"), [\"@\", \"{}\"]]], ...body];\n    return compile_ast(ast);\n  }\n  case \"set!\":\n    return compile_ast(ast[1]) + \"=\" + compile_ast(ast[2]);\n  case \"throw\": {\n    return \"(function(){throw \" + compile_ast(ast[1]) + \"})()\";\n  }\n  case \"try\": {\n    let result = \"(function(){try{return \" + compile_ast(ast[1]) + \"}catch(\";\n    if (common.to_id(ast[2][0]) != \"catch\") throw \"try without catch clause\";\n    result += common.to_id(ast[2][1]) + \"){return \" + compile_body(ast[2], 2) + \"}\";\n    result += \"})()\";\n    return result;\n  }\n  case \"until\":\n  case \"while\": {\n    let condition = compile_ast(ast[1]);\n    if (common.to_id(ast[0]) === \"until\")\n      condition = \"!\" + condition;\n    return (\"((function(){while(\" +\n            condition +\n            \"){\" +\n            compile_body(ast, 2) +\n            \"}})(),null)\");\n  }\n  case \".\": {\n    let op = \"+\";\n    let rest = ast.slice(1);\n    let result = [];\n    for (let i = 0; i < rest.length; i++) {\n      if (i > 0) result.push(op);\n      result.push(compile_string(rest[i]));\n    }\n    return result.join(\"\");\n  }\n  case \"=\":\n    return \"(\" + compile_ast(ast[1]) + \"===\" + compile_ast(ast[2]) + \")\";\n  case \"%\":\n  case \"==\":\n  case \"===\":\n  case \"!=\":\n  case \"!==\":\n  case \"<\":\n  case \">\":\n  case \"<=\":\n  case \">=\":\n    return \"(\" + compile_number(ast[1]) + common.to_id(ast[0]) + compile_number(ast[2]) + \")\";\n  case \"&&\":\n  case \"||\":\n  case \"&\":\n  case \"|\":\n  case \"+\":\n  case \"-\":\n  case \"*\":\n  case \"**\":\n  case \"/\": {\n    return \"(\" + insert_op(common.to_id(ast[0]), ast.slice(1)) + \")\";\n  }\n  default: {\n    let fcall = common.to_id(ast[0]) + \"(\";\n    for (let i = 1; i < ast.length; i++) {\n      if (i > 1)\n        fcall += \",\";\n      fcall += compile_ast(ast[i]);\n    }\n    fcall += \")\";\n    return fcall;\n  }\n  }\n}\n\nfunction insert_op(op, rest) {\n  if (rest.length === 1)\n    return op + compile_number(rest[0]);\n  let result = [];\n  for (let i = 0; i < rest.length; i++) {\n    if (i > 0) result.push(op);\n    result.push(compile_number(rest[i]));\n  }\n  return result.join(\"\");\n}\n\nfunction compile_do(ast) {\n  let ast1 = ast[1];\n  let parallel = ast[0] === \"do\";\n  let ast1_len = ast1.length;\n  let ast1_vars = [];\n  if (parallel) {\n    ast1_vars.push(\"__do__\");\n    ast1_vars.push(\"new Array(\" + ast1_len + \").fill(null)\");\n  }\n  ast1.forEach((x) => {\n    ast1_vars.push(x[0]);\n    ast1_vars.push(x[1]);\n  });\n  let ast2 = ast[2];\n  if (ast2.length < 2)\n    ast2 = [ast2[0], null];\n  let until_ast = [common.id(\"until\"), ast2[0]].concat(ast.slice(3));\n  if (parallel) {\n    ast1.forEach((x, i) => {\n      if (x.length < 3)\n        return;\n      let next_step = [id(\"set!\"), \"__do__[\" + i + \"]\", x[2]];\n      until_ast.push(next_step);\n    });\n    ast1.forEach((x, i) => {\n      if (x.length < 3)\n        return;\n      let next_step = [id(\"set!\"), x[0], \"__do__[\" + i + \"]\"];\n      until_ast.push(next_step);\n    });\n  }\n  else {\n    ast1.forEach((x) => {\n      if (x.length < 3)\n        return;\n      let next_step = [common.id(\"set!\"), x[0], x[2]];\n      until_ast.push(next_step);\n    });\n  }\n  let new_ast = [parallel ? common.id(\"_let\") : common.id(\"_let*\"), ast1_vars].concat([until_ast]);\n  new_ast.push(ast2[1]);\n  return compile_ast(new_ast);\n}\n\nfunction omljs() {\n  let glob = {};\n  glob.compile_ast = (ast, debug) => {\n    if (debug)\n      console.log(\" [AST] \" + JSON.stringify(ast));\n    let code = compile_ast(ast);\n    if (debug)\n      console.log(\"[CODE] \" + code);\n    return code;\n  };\n  glob.compile = (text, debug) => {\n    let steps = (0,_oml2ast_js__WEBPACK_IMPORTED_MODULE_0__.oml2ast)(text);\n    let result = \"\";\n    for (let step of steps) {\n      let exp = step[0];\n      let ast = step[1];\n      if (debug)\n        console.log(\" [OML] \" + exp);\n      if (debug)\n        console.log(\" [AST] \" + JSON.stringify(ast));\n      let code = compile_ast(ast);\n      if (debug)\n        console.log(\"[CODE] \" + code);\n      result += code + \";\\n\";\n    }\n    return result;\n  };\n  glob.exec_d = (exp) => glob.exec(exp, true);\n  glob.exec = (exp, debug) => {\n    let src = exp;\n    let steps = (0,_oml2ast_js__WEBPACK_IMPORTED_MODULE_0__.oml2ast)(src);\n    let last;\n    let text = \"\";\n    for (let step of steps) {\n      let exp = step[0];\n      let ast = step[1];\n      var tm1 = new Date().getTime();\n      try {\n        if (debug)\n          console.log(\" [OML] \" + exp);\n        if (debug)\n          console.log(\" [AST] \" + JSON.stringify(ast));\n        text = compile_ast(ast);\n        if (debug)\n          console.log(\"[CODE] \" + text);\n        let val = eval(text);\n        last = val;\n        let output;\n        if (typeof val === \"function\") {\n          output = \"function\";\n        }\n        else if (!(val instanceof Array) &&\n                 val instanceof Object &&\n                 Object.prototype.toString.call(val) !== \"[object Object]\") {\n          try {\n            output =\n              Object.prototype.toString.call(val) + \" \" + JSON.stringify(val);\n          }\n          catch (e) { }\n        }\n        else {\n          try {\n            output = JSON.stringify(val);\n          }\n          catch (e) { }\n        }\n        var tm2 = new Date().getTime();\n        if (debug) {\n          if (output === undefined) {\n            console.log(\"==> (\" + (tm2 - tm1) + \" ms)\");\n            console.log(val);\n          }\n          else {\n            console.log(\"==> \" + output + \" (\" + (tm2 - tm1) + \" ms)\");\n          }\n        }\n      }\n      catch (e) {\n        if (!debug)\n          console.log(\" [OML] \" + exp);\n        if (!debug)\n          console.log(\" [AST] \" + JSON.stringify(ast));\n        if (!debug)\n          console.log(\"[CODE] \" + text);\n        console.log(\"[EXCEPTION]\");\n        if (e.stack)\n          console.log(e.stack);\n        else\n          console.log(e);\n        throw e;\n        // removed by dead control flow\n\n      }\n    }\n    return last;\n  };\n  glob.run = (exp) => glob.exec(exp, true);\n  glob.execAll = (exp, debug) => {\n    let text = glob.compile(exp, debug);\n    try {\n      return eval(text);\n    } catch (e) {\n      if (e.stack)\n        console.log(e.stack);\n      else\n        console.log(e);\n      throw e;\n    }\n  };\n  glob.runAll = (exp) => {\n    return glob.execAll(exp, true);\n  };\n  return glob;\n}\nglobalThis.omljs = omljs;\n\nfunction run(exp) {\n  let o = omljs();\n  return o.run(exp);\n}\nglobalThis.run = run;\n\nfunction runAll(exp) {\n  let o = omljs();\n  return o.runAll(exp);\n}\nglobalThis.runAll = runAll;\n\nfunction print(x) {\n  console.log((0,_oml2ast_js__WEBPACK_IMPORTED_MODULE_0__.ast2oml)(x));\n  return x;\n}\nglobalThis.print = print;\n\nfunction number_value(x) {\n  return typeof x !== \"number\" ? 0 : x;\n}\nglobalThis.number_value = number_value;\n\nfunction equal(a, b) {\n  return (0,_oml2ast_js__WEBPACK_IMPORTED_MODULE_0__.astequal)(a, b);\n}\nglobalThis.equal = equal;\n\n\n//# sourceURL=webpack:///./src/omljs.js?\n}");

/***/ },

/***/ "./src/omljs.mjs"
/*!***********************!*\
  !*** ./src/omljs.mjs ***!
  \***********************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   runAll: () => (/* binding */ runAll)\n/* harmony export */ });\n/* harmony import */ var _omljs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./omljs.js */ \"./src/omljs.js\");\n\nconst run = globalThis.run;\nconst runAll = globalThis.runAll;\n\n\n//# sourceURL=webpack:///./src/omljs.mjs?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		if (!(moduleId in __webpack_modules__)) {
/******/ 			delete __webpack_module_cache__[moduleId];
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/omljs.mjs");
/******/ 	
/******/ })()
;